
#include "a3.h"
#include <assert.h>


define_array_implementation(Symbol);
define_array_implementation(binding_ptr);
define_hmap_implementation(Symbol, binding_t, Symbol_hash, Symbol_eq);

#define each(el, source) for(ASTList * _##el = source; _##el; _##el = _##el->next) { ASTAtom el = _##el->car;
#define end_each }

#define end }

#define matchcar(into, from) into = from->car; from = from->next;
#define dropcar(from) from = from->next;

#define ifcars(c, s, r) if(c.type == ASTListType && c.d._ASTList && c.d._ASTList->car.type == SymbolType && Symbol_eq(c.d._ASTList->car.d._Symbol, symbol(s))) { ASTList * r = c.d._ASTList->next;
#define elifcars(c, s, r) } else ifcars(c, s)
#define elsecars } else {
#define end_if }

env_t global;

typedef struct {
	int tag;
	int line, column;
	
	type_t * type;
} expr_t;

typedef struct {
	expr_t e;
	
	expr_t * fun;
	expr_t * arg;
} eapp_t;

typedef struct {
	expr_t e;
	
	binding_t * b;
} eref_t;

typedef struct {
	expr_t e;
	
	ASTAtom lit;
} elit_t;

#define EXPR_APP 0
#define EXPR_REF 1
#define EXPR_LIT 2
#define EXPR_DO 3
#define ELAM 4

#define ENV_GLOBAL 0
#define ENV_PROC 1

typedef struct {
	env_t env;
	
	expr_t * body;
	array_Symbol pnames;
	
	array_binding_ptr closure;
} proc_t;

// builtin forms!!

// function body: constraints are generated by unifying expressions
// with the arguments and return type. a record of expressions whose
// return type is completely unbound is kept, for future errors.
// forward references, for simplicty, not allowed. must have a prior
// type declaration (prototype) to use.

// because all typevars are bound to the arguemts/return, free vars
// can be found simply by traversing the typesignature, so that a forall
// can be generated. no foralls inside the left part of an arrow will
// be inferred. quantification will be specified in order of appearance
// in the signature. recursion is allowed, as the type variable of the
// signature is at hand. the signature will be 'cleaned' of unnecessary
// tvar indirection for efficient usage in other pieces of code, but the
// types in the body need not be, since the cost will only be incurred
// on code generation.

// because all globals are typed (no forward refs), they are available
// for unification. they don't have any unbound variables btw, only
// quantified ones which will be instantiated.

// locals to the left, globals (no free vars) to the right. unification
// can turn into "Ais instance of polymorphic type B"-type constraints.
// both sides sorted, vars will tend to be on the left.

// occurs check???? how???

binding_t * getb(env_t * env, Symbol name) {
	hnode_Symbol_binding_t ** b = hmap_Symbol_binding_t_getptrptr(&(env->dict), name);
	binding_t * pb;
	
	if(*b) return &((*b)->value);
	else if (pb = getb(env->parent, name)) {
		if(env->tag == ENV_PROC && pb->scope != GLOBAL) { // what if it's of scope recur??
			fprintf(stderr, "closure");
			proc_t * proc = (proc_t *) env;
			binding_t newb;
			
			newb.type = pb->type;
			newb.scope = CLOSURE;
			newb.id = proc->closure.size;
			array_binding_ptr_push(&proc->closure, pb);
			newb.name = name;
			newb.hasvalue = 0;
			
			*b = malloc(sizeof(hnode_Symbol_binding_t));
			(*b)->key = name;
			(*b)->value = newb;
			(*b)->next = NULL;
		} else return pb; // if not a proc or just a global value.
	} else return NULL;
}


expr_t * functcall(env_t * env, ASTList * body);

expr_t * expression(env_t * env, ASTAtom exp, bool tail) {
	expr_t * newexp;
	switch(exp.type) {
	case LongType: {
		elit_t * lit = malloc(sizeof(elit_t));
		lit->lit = exp;
		newexp = (expr_t *) lit;
		newexp->tag = EXPR_LIT;
		newexp->type = type_int;
	} case BoolType: {
		elit_t * lit = malloc(sizeof(elit_t));
		lit->lit = exp;
		newexp = (expr_t *) lit;
		newexp->tag = EXPR_LIT;
		newexp->type = type_bool;
	} case SymbolType: {
		eref_t * ref = malloc(sizeof(elit_t));
		ref->b = getb(env, exp.d._Symbol);
		newexp = (expr_t *) ref;
		newexp->tag = EXPR_REF;
		newexp->type = ref->b->type;
	} case ASTListType: {
		ifcars(exp, "if", body)
		elsecars
			newexp = functcall(env, exp.d._ASTList);
		end_if
	}}
	
	return newexp;
} 

expr_t * functcall(env_t * env, ASTList * body) {
	assert(body);
	
	expr_t * n = expression(env, body->car, false);
	
	each(nexp, body->next)
		eapp_t * app = malloc(sizeof(eapp_t));
		app->e.tag = EXPR_APP;
		app->fun = n;
		app->arg = expression(env, nexp, false);
		
		type_unite_app(&app->fun->type, &app->arg->type, &app->e.type);
		n = (expr_t *) app;
	end_each
	
	return n;
}

void top(env_t * env, ASTList * code) {
	each(el, code)
		ifcars(el, "=", body)
			ASTAtom lhs, rhs;
			
			matchcar(lhs, body);
			matchcar(rhs, body);
			
			// handle declarations like "type List a = ..."
			
			if(lhs.type == ASTListType) {
				ASTList * pl = lhs.d._ASTList->next;
				
				lhs = lhs.d._ASTList->car;
				rhs = AASTList(ASTList_new(Asymbol("->"), ASTList_new(AASTList(pl), ASTList_new(rhs, NULL))));
			}
			
		end_if
	end_each
}

void addps(array_Symbol * pnames, ASTAtom ps) {
	if(ps.type == SymbolType) {
		array_Symbol_push(pnames, ps.d._Symbol);
	} else {
		assert(ps.type == ASTListType);
		
		each(el, ps.d._ASTList)
			assert(el.type == SymbolType);
			
			array_Symbol_push(pnames, el.d._Symbol);
		end_each
	}
}

int lambda(env_t * env, ASTList * body, Symbol name) {
	proc_t * p = malloc(sizeof(proc_t));
	p->pnames = array_Symbol_new(64);
	p->closure = array_binding_ptr_new(64);
	p->env.tag = ENV_PROC;
	p->env.parent = env;
	p->env.dict = hmap_Symbol_binding_t_new(64);
	
	// collapse (x -> y -> x + y) into (x y -> x + y)
	// does not collapse (x -> do (y -> x + y))
	// should
	
	ASTAtom exp;
	
	for(;;) { // when will it end?
		ASTAtom ps;
		matchcar(ps, body);
		addps(&p->pnames, ps);
		matchcar(exp, body);
		
		ifcars(exp, "->", rbody)
			body = rbody;
		elsecars
			break;
		end_if
	}
	
	binding_t b;
	
	times(i, p->pnames.size) {
		b.type = NULL; // new type variable
		b.scope = PARAMETER;
		b.id = i;
		b.name = p->pnames.arr[i];
		b.hasvalue = 0;
		
		hmap_Symbol_binding_t_put(&p->env.dict, p->pnames.arr[i], b);
	}
	
	
}


#if 0

typedef struct {
	type_t * type;
	scope_t scope;
	int id;
	int realid; // for non-parametric or unconstrained parametric types, same as id
	
	Symbol name;
	
	int hasvalue;
	anydata value;
	//int arity;
} binding_t;

Expr = Term | App Exp Exp

type MyInt = My int

fun x y z = x + y + z

x + y + z

app (+) (x)

(((f 1) 2) 3)



fun =
	x ->
		y z ->
			x + y + z

instance (Print a) => (Print (List a))
	print = vmap print
	
foldr f v l = match l
	Nil => v
	x : xs => (f x) : (foldr f v xs)

min a b = cond
	a < b => do
		print "max is"
		println a
		a
	a == b => do
		a
		aa ()
		
		qq
		
	else =>
		b
		
map (x -> x + 2) list

main () = do
	var (Just x) <- readint()
	var (Just y) <- readint()
	
	println x + y
	
main () = pri
		
countermake i = do
	c := box i
	
	() -> do
		^c <- ^c + 1
		^c

class (Monad m)
	(>>=) :: m a -> (a -> m b) -> m b


print x
	+ 4
	+ (feenn s)

? expressions..

match x
	Nothing => Nothing
	Just y => match y.a
		Nothing => Nothing
		Just z => z.b

becomes

begin
	r <- x
	s <- r.y
	t <- s.b
	return t

?x.?y.?b

a : int
b : maybe int

a + ?b

x := lazy fac 20000

y := begin ?x + 5



implement monads! parser, list comprehension...
handling errors (maybe, etc), begin (do) notation, let
resource...

laziness! Stream / Seq... a general type class, plus instances
for lists, enumerators, parallel producer/consumer channels or pipes

Lazy monad??

make let syntax pretty
macro system, metador.

compile monads into efficient eagerly evaluated code

green threads (nono), grand central dispatch-like multithreading
with closures that are allocated systhreads


thunks - lambdas that do something when applied to a () value.

thunk := () -> print "hola"
thunk () ; prints hola

can be used for parallel tasks!

i := 0
while i < 100
	dispatch 
		() -> compute i
	
	i += 1
	
consider OpenMP, Go, GCD, occam, for parallelism. also fold for joining

void type - occupies no space. only serves to delay functional
application and to type non-expressive statements (can it be stored?? 
can constructors take void params?
should it behave like the unit type, where it can be stored (as a zero)
or not?
() - value of the void type. nop.

how to handle the following?

func () () = print "hola"

clearly not curried application. rather by making several fuctions,
adding call indirection:

func:
clos func1 0
ret
func1:
ldc "hola"
call print
ret

A call to func would always be so:

func () ()
call func
appv
func ()
call func
func
clos func 0

FORGET THE VOID TYPE! EVIL! CANNOT WORK WITH PARAMETRIC POLYMORPHISM OR
STORAGE!!!!!!!!!!!!!!!! Vor just disallow tvariables to represent void.
treat it differently. cannot be used in type constructors or variables.
perhaps even give it another kind! *, * -> *..., .

unit type - isomorphic to the void type, but occupies actual space. can
be stored.

type unit = unit

unique pointers?? pointer ownership and semantics!! to ease the work of
of gc.

x := unique 3

dosome (move x) 4

; the move instruction copies the pointer to the arg of another function
and invalidates the original copy. if ownership has not been transferred
at the end of a function/block, pointed value is freed.

syntax extension

aa = x < 3 ?? Yes !! No

ternary operator ?! - ?? !!.

compiled interfaces

module Lista (Lista, car, cdr)
	type Lista a = Nil | Lista !car :a !cdr :(Lista a)


::::::::
Lista
types
Lista :: * -> *
values
Nil :: Lista a
Lista :: a => a -> Lista a -> Lista a
car = ATTR Lista 0
	@get :: a => Lista a -> aista a
	@set :: a => Lista a -> a -> void
cdr = ATTR Lita 1
	@get :: a => Lista a -> Lista a
	@set :: a => Lista a -> Lista a -> void

Mutable attributes with !, ref cells, arrays...

option monad:
?int

lift function for option types: ?
shorthand or sugar style for monadic code, to make it easier to handle
option values.

decide on memory representation of adts, preferrably one that makes
distinguishing pointers from integers easy.


readInt :: File -> ?int

free :: a -> void

x := list 2 3 4 5

vmap println x

free x

region - surrounds code that uses a new region in this thread.
everything allocated inside it is deallocated at once after control
exits the region, to avoid overloading the GC. escape analysis???

dataflow variables! Oz Prolog
channels! ports! concurrent streams!!!!! producer consumer, futures,
concurrency monads, monads for futures, dataflow variables, channels,
streams, option types, exceptions, continuations.
Erlang
Message passing

http://en.wikipedia.org/wiki/Oz_(programming_language)
http://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/

begin 
	x <- [1, 2, 3, 4, 5]
	y <- [5, 4, 3, 2, 1]
	guard x < y
	return x, y

getIntLine () = begin
	
is the return necessary??

suma :: Maybe int -> Maybe int -> Maybe int
suma x y = begin
	?x + ?y

#endif
